# Техническое задание на разработку SQLRC

## 1. Введение

### 1.1 Назначение документа

Данный документ содержит спецификацию функциональных требований к программной системе SQLRC (SQL Record Creator). Документ предназначен для разработчиков, тестировщиков и других заинтересованных лиц, участвующих в создании системы.

### 1.2 Цели и задачи проекта

Целью проекта является создание инструмента командной строки, который будет автоматизировать процесс создания кода на языке Go для работы с базами данных. Система должна анализировать SQL-файлы со схемой базы данных и запросами, а затем генерировать соответствующие структуры данных и функции для взаимодействия с базой данных через стандартную библиотеку Go `database/sql`.

Основные задачи проекта:
- Разработка парсера SQL-файлов для извлечения информации о таблицах и запросах
- Разработка генератора Go-кода для создания структур данных и функций
- Разработка интерфейса командной строки для взаимодействия с пользователем
- Обеспечение простой конфигурации через текстовый файл

## 2. Описание функциональности

### 2.1 Общее описание системы

SQLRC будет представлять собой инструмент командной строки, который принимает на вход конфигурационный файл, содержащий пути к SQL-файлам и другие параметры. На основе этих файлов система будет генерировать Go-код, который можно будет использовать в проектах для типобезопасного взаимодействия с базой данных.

### 2.2 Варианты использования

#### Вариант использования 1: Генерация кода на основе схемы базы данных

**Действующее лицо:** Разработчик

**Предусловия:**
- Разработчик имеет SQL-файл с определениями таблиц (CREATE TABLE)
- Разработчик имеет установленную систему SQLRC

**Основной сценарий:**
1. Разработчик создает конфигурационный файл, указывая путь к файлу схемы и другие параметры
2. Разработчик запускает SQLRC с параметром `--cfg`, указывающим на конфигурационный файл
3. Система анализирует файл схемы, извлекая информацию о таблицах и их структуре
4. Система генерирует Go-код с определениями структур данных, соответствующих таблицам
5. Система сохраняет сгенерированный код в файл `schema.go` в указанной директории
6. Система выводит сообщение об успешной генерации кода

**Постусловия:**
- В указанной директории создан файл `schema.go` с определениями структур данных

#### Вариант использования 2: Генерация кода для выполнения запросов

**Действующее лицо:** Разработчик

**Предусловия:**
- Разработчик имеет SQL-файл с запросами, содержащими специальные комментарии и параметры
- Разработчик имеет установленную систему SQLRC

**Основной сценарий:**
1. Разработчик указывает путь к файлу запросов в конфигурационном файле
2. Разработчик запускает SQLRC с параметром `--cfg`
3. Система анализирует файл запросов, извлекая информацию о запросах, их параметрах и типах возвращаемых значений
4. Система генерирует Go-код с функциями для выполнения запросов, структурами для параметров и результатов
5. Система сохраняет сгенерированный код в файл `query.go` в указанной директории
6. Система выводит сообщение об успешной генерации кода

**Постусловия:**
- В указанной директории создан файл `query.go` с функциями для выполнения запросов

#### Вариант использования 3: Интеграция сгенерированного кода в проект

**Действующее лицо:** Разработчик

**Предусловия:**
- Разработчик имеет сгенерированные файлы `schema.go` и `query.go`
- Разработчик имеет Go-проект, в котором нужно использовать сгенерированный код

**Основной сценарий:**
1. Разработчик импортирует сгенерированный пакет в свой Go-проект
2. Разработчик создает экземпляр структуры `Queries`, передавая ей соединение с базой данных
3. Разработчик вызывает сгенерированные функции для выполнения запросов к базе данных
4. Система обеспечивает типобезопасное взаимодействие с базой данных через сгенерированный код

**Постусловия:**
- Проект разработчика использует сгенерированный код для взаимодействия с базой данных

## 3. Функциональные требования

### 3.1 Парсинг конфигурационного файла

**Требование 3.1.1:** Система должна читать конфигурационный файл в формате "key:value\n".

**Требование 3.1.2:** Система должна поддерживать следующие параметры конфигурации:
- `schema` - путь к файлу схемы SQL (обязательный параметр)
- `queries` - путь к файлу запросов SQL (обязательный параметр)
- `remove_trailing_s` - флаг для удаления окончания "s" из имен таблиц (необязательный параметр, по умолчанию false)
- `pakage.name` - имя пакета Go (обязательный параметр)
- `pakage.path` - путь к директории, в которую будут сгенерированы файлы (обязательный параметр)

**Требование 3.1.3:** Система должна корректно обрабатывать относительные и абсолютные пути в конфигурационном файле.

**Требование 3.1.4:** Система должна выдавать понятные сообщения об ошибках при отсутствии обязательных параметров или некорректном формате файла.

### 3.2 Чтение и анализ файла схемы базы данных

**Требование 3.2.1:** Система должна читать SQL-файл с определениями таблиц (CREATE TABLE).

**Требование 3.2.2:** Система должна корректно обрабатывать комментарии в SQL-коде, игнорируя их при анализе.

**Требование 3.2.3:** Система должна извлекать имена таблиц из операторов CREATE TABLE.

**Требование 3.2.4:** Система должна извлекать имена, типы и атрибуты полей таблиц.

**Требование 3.2.5:** Система должна поддерживать следующие типы данных SQL:
- TEXT - соответствует типу string в Go
- INTEGER - соответствует типу int в Go

**Требование 3.2.6:** Система должна определять, является ли поле обязательным (NOT NULL) или опциональным.

**Требование 3.2.7:** Система должна корректно обрабатывать первичные ключи (PRIMARY KEY).

**Требование 3.2.8:** Система должна выдавать понятные сообщения об ошибках при обнаружении неподдерживаемых типов данных или некорректного синтаксиса SQL.

### 3.3 Чтение и анализ файла запросов

**Требование 3.3.1:** Система должна читать SQL-файл с запросами.

**Требование 3.3.2:** Система должна распознавать специальные комментарии формата `--@ sqlrc:ИмяФункции:ТипВозврата`.

**Требование 3.3.3:** Система должна поддерживать следующие типы возвращаемых значений:
- `one` - запрос, возвращающий одну запись
- `many` - запрос, возвращающий несколько записей
- `exec` - запрос, не возвращающий данные (INSERT, UPDATE, DELETE)

**Требование 3.3.4:** Система должна распознавать параметры запросов в формате `<@имя_параметра:тип_параметра@>`.

**Требование 3.3.5:** Система должна поддерживать следующие типы параметров:
- `string` - строковый тип
- `int` - целочисленный тип

**Требование 3.3.6:** Система должна корректно обрабатывать повторяющиеся параметры в запросе, заменяя их на плейсхолдеры `?` в сгенерированном SQL-коде.

**Требование 3.3.7:** Система должна анализировать результаты запросов для определения структуры возвращаемых данных.

**Требование 3.3.8:** Система должна выдавать понятные сообщения об ошибках при обнаружении неподдерживаемых типов параметров или некорректного синтаксиса SQL.

### 3.4 Генерация кода схемы

**Требование 3.4.1:** Система должна генерировать Go-код с определениями структур данных, соответствующих таблицам базы данных.

**Требование 3.4.2:** Сгенерированный код должен содержать структуру `Queries` с полем `DB` типа `*sql.DB`.

**Требование 3.4.3:** Для каждой таблицы должна быть сгенерирована отдельная структура с полями, соответствующими полям таблицы.

**Требование 3.4.4:** Имена структур должны быть в формате PascalCase, с первой буквой в верхнем регистре.

**Требование 3.4.5:** Если параметр `remove_trailing_s` установлен в true, система должна удалять окончание "s" из имен таблиц при генерации имен структур.

**Требование 3.4.6:** Поля структур должны иметь теги `db` с именами соответствующих полей таблицы.

**Требование 3.4.7:** Типы полей структур должны соответствовать типам полей таблицы:
- TEXT -> string
- INTEGER -> int

**Требование 3.4.8:** Сгенерированный код должен быть корректным Go-кодом, который компилируется без ошибок.

**Требование 3.4.9:** Сгенерированный код должен содержать импорт пакета `database/sql`.

### 3.5 Генерация кода запросов

**Требование 3.5.1:** Система должна генерировать Go-код с функциями для выполнения запросов к базе данных.

**Требование 3.5.2:** Для каждого запроса должна быть сгенерирована константа с SQL-запросом, в котором параметры заменены на плейсхолдеры `?`.

**Требование 3.5.3:** Для каждого запроса с параметрами должна быть сгенерирована структура с полями, соответствующими параметрам запроса.

**Требование 3.5.4:** Для запросов типа `one` и `many` должна быть сгенерирована структура с полями, соответствующими результатам запроса.

**Требование 3.5.5:** Для каждого запроса должна быть сгенерирована функция, принимающая контекст и структуру параметров и возвращающая результаты запроса.

**Требование 3.5.6:** Функции для запросов типа `one` должны возвращать указатель на структуру результата и ошибку.

**Требование 3.5.7:** Функции для запросов типа `many` должны возвращать срез структур результата и ошибку.

**Требование 3.5.8:** Функции для запросов типа `exec` должны возвращать результат выполнения запроса и ошибку.

**Требование 3.5.9:** Сгенерированный код должен корректно обрабатывать NULL-значения в результатах запросов.

**Требование 3.5.10:** Сгенерированный код должен быть корректным Go-кодом, который компилируется без ошибок.

**Требование 3.5.11:** Сгенерированный код должен содержать импорт пакета `context`.

### 3.6 Запись сгенерированных файлов

**Требование 3.6.1:** Система должна создавать директорию для сгенерированных файлов, если она не существует.

**Требование 3.6.2:** Система должна записывать сгенерированный код схемы в файл `schema.go` в указанной директории.

**Требование 3.6.3:** Система должна записывать сгенерированный код запросов в файл `query.go` в указанной директории.

**Требование 3.6.4:** Система должна корректно обрабатывать относительные и абсолютные пути при записи файлов.

**Требование 3.6.5:** Система должна выдавать понятные сообщения об ошибках при невозможности создания директории или записи файлов.

### 3.7 Интерфейс командной строки

**Требование 3.7.1:** Система должна предоставлять интерфейс командной строки с параметром `--cfg <путь_к_конфигурационному_файлу>`.

**Требование 3.7.2:** Система должна выводить информацию о ходе выполнения, включая сообщения о чтении файлов, генерации кода и записи файлов.

**Требование 3.7.3:** Система должна выводить сообщения об ошибках в понятном формате, указывая причину ошибки и возможные способы ее устранения.

**Требование 3.7.4:** Система должна возвращать ненулевой код возврата в случае ошибки.

### 3.8 Обработка ошибок

**Требование 3.8.1:** Система должна корректно обрабатывать ошибки чтения файлов, выдавая понятные сообщения.

**Требование 3.8.2:** Система должна корректно обрабатывать ошибки парсинга SQL-кода, указывая на проблемные места.

**Требование 3.8.3:** Система должна корректно обрабатывать ошибки генерации кода, указывая на причины ошибок.

**Требование 3.8.4:** Система должна корректно обрабатывать ошибки записи файлов, указывая на возможные причины (отсутствие прав доступа, недостаток места и т.д.).

**Требование 3.8.5:** Система должна предоставлять достаточно информации для диагностики и устранения ошибок.

## 4. Нефункциональные требования

### 4.1 Производительность

**Требование 4.1.1:** Система должна обрабатывать файлы схемы и запросов размером до 10 МБ за приемлемое время (не более 5 секунд на файл).

**Требование 4.1.2:** Система должна эффективно использовать память, не допуская утечек памяти при обработке больших файлов.

### 4.2 Надежность

**Требование 4.2.1:** Система должна корректно обрабатывать некорректные входные данные, выдавая понятные сообщения об ошибках.

**Требование 4.2.2:** Система не должна аварийно завершаться при обработке некорректных входных данных.

**Требование 4.2.3:** Система должна сохранять целостность существующих файлов при возникновении ошибок в процессе генерации кода.

### 4.3 Удобство использования

**Требование 4.3.1:** Система должна предоставлять понятные сообщения об ошибках, указывая на причину ошибки и возможные способы ее устранения.

**Требование 4.3.2:** Система должна иметь простой и интуитивно понятный интерфейс командной строки.

**Требование 4.3.3:** Система должна предоставлять достаточно информации о ходе выполнения, чтобы пользователь мог понять, что происходит.

### 4.4 Сопровождаемость

**Требование 4.4.1:** Код системы должен быть хорошо структурирован и документирован.

**Требование 4.4.2:** Система должна быть модульной, с четко определенными интерфейсами между модулями.

**Требование 4.4.3:** Система должна быть легко расширяемой для поддержки новых типов данных SQL и новых типов запросов.

## 5. Ограничения и допущения

### 5.1 Технические ограничения

**Ограничение 5.1.1:** Система будет реализована на языке Pascal (Free Pascal Compiler).

**Ограничение 5.1.2:** Система будет работать в командной строке без графического интерфейса.

**Ограничение 5.1.3:** Система будет генерировать код только для языка Go.

### 5.2 Допущения

**Допущение 5.2.1:** Пользователи системы знакомы с SQL и Go.

**Допущение 5.2.2:** Пользователи системы имеют базовые навыки работы с командной строкой.

**Допущение 5.2.3:** Входные SQL-файлы имеют корректный синтаксис SQL.

## 6. Примеры использования

### 6.1 Пример конфигурационного файла

```
schema:schema.sql
queries:user.sql
remove_trailing_s:true
pakage.name:gen
pakage.path:./__gen/
```

### 6.2 Пример файла схемы SQL

```sql
CREATE TABLE users (
    primary_currency TEXT NOT NULL DEFAULT 'BYN',
    username TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,
    image TEXT NOT NULL,
    id INTEGER PRIMARY KEY NOT NULL,
    balance INTEGER NOT NULL DEFAULT 0
);
```

### 6.3 Пример файла запросов SQL

```sql
--@ sqlrc:GetSingle:one
SELECT *
FROM users
WHERE username = <@username:string@>;

--@ sqlrc:GetMany:many
SELECT users.* FROM users WHERE id < <@id:int@>;

--@ sqlrc:InsertUser:exec
INSERT INTO users (username, password, image)
VALUES (<@username:string@>, <@password:string@>, <@image:string@>);
```

### 6.4 Пример использования сгенерированного кода

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "log"
    
    "example.com/myapp/gen"
    _ "github.com/mattn/go-sqlite3"
)

func main() {
    db, err := sql.Open("sqlite3", "./test.db")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    queries := gen.Queries{DB: db}
    
    // Получение пользователя по имени
    user, err := queries.GetSingle(context.Background(), gen.GetSingleParams{
        Username: "john",
    })
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("User: %+v\n", user)
}
